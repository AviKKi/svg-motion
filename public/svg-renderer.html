<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SVG Animation Renderer</title>
    <script src="https://unpkg.com/animejs@3.2.1/lib/anime.min.js"></script>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden; /* prevent scrollbars on both axes */
      }

      body {
        display: flex;
        align-items: center;
        justify-content: center;
        background: transparent;
      }

      #svg-container {
        width: 100vw;
        height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden; /* clip any potential overflow from strokes/filters */
        background: transparent;
      }

      svg {
        display: block;
        width: 100%;
        height: 100%;
      }
    </style>
  </head>
  <body>
    <div id="svg-container"></div>

    <script type="module">
      import {
        animate,
        createSpring,
        createTimeline,
      } from 'https://cdn.jsdelivr.net/npm/animejs/+esm';
      // console.log(animate);
      let currentTimeline = null;
      let currentAnimations = [];
      let svgContent = '';
      let isPlaying = false;
      let currentTime = 0;
      let ignoreNextTimeUpdate = false; // suppress echo after external seek

      // Communication with parent window
      function sendMessage(type, data = {}) {
        window.parent.postMessage({ type, ...data }, '*');
      }

      // Initialize SVG content
      function setSvgContent(content) {
        svgContent = content;
        const container = document.getElementById('svg-container');
        container.innerHTML = content;

        // Ensure the injected SVG scales to fit the viewport without overflow
        const svgEl = container.querySelector('svg');
        if (svgEl) {
          svgEl.setAttribute('preserveAspectRatio', 'xMidYMid meet');
          svgEl.style.width = '100%';
          svgEl.style.height = '100%';
          svgEl.style.maxWidth = '100%';
          svgEl.style.maxHeight = '100%';
          svgEl.style.display = 'block';

          // Provide a viewBox if missing so aspect ratio is maintained
          if (!svgEl.hasAttribute('viewBox')) {
            const widthAttr = svgEl.getAttribute('width');
            const heightAttr = svgEl.getAttribute('height');
            let w = parseFloat(widthAttr || '');
            let h = parseFloat(heightAttr || '');

            if (!w || !h || Number.isNaN(w) || Number.isNaN(h)) {
              try {
                const bbox = svgEl.getBBox();
                if (bbox && bbox.width && bbox.height) {
                  svgEl.setAttribute(
                    'viewBox',
                    `${bbox.x} ${bbox.y} ${bbox.width} ${bbox.height}`
                  );
                } else {
                  svgEl.setAttribute('viewBox', '0 0 100 100');
                }
              } catch (e) {
                svgEl.setAttribute('viewBox', '0 0 100 100');
              }
            } else {
              svgEl.setAttribute('viewBox', `0 0 ${w} ${h}`);
            }
          }
        }

        // Notify parent that SVG is loaded
        sendMessage('svg-loaded');
      }

      // Helper function to process ease configurations
      function processEaseConfig(ease) {
        if (typeof ease === 'object' && ease.type === 'spring') {
          return createSpring(ease);
        }
        return ease;
      }

      // Helper function to process animation parameters
      function processAnimationParams(params) {
        const processedParams = { ...params };
        
        // Process each property that might have ease configurations
        Object.keys(processedParams).forEach(key => {
          const value = processedParams[key];
          
          if (Array.isArray(value)) {
            // Handle keyframe arrays
            processedParams[key] = value.map(keyframe => ({
              ...keyframe,
              ease: keyframe.ease ? processEaseConfig(keyframe.ease) : keyframe.ease
            }));
          } else if (typeof value === 'object' && value.ease) {
            // Handle single keyframe objects
            processedParams[key] = {
              ...value,
              ease: processEaseConfig(value.ease)
            };
          }
        });
        
        return processedParams;
      }

      // Create animation timeline
      function createAnimationTimeline(animations) {
        // Clear existing timeline
        if (currentTimeline) {
          currentTimeline.pause();
          currentTimeline = null;
        }

        currentAnimations = animations;

        if (!animations || animations.length === 0) {
          return;
        }

        // Create new timeline
        currentTimeline = createTimeline({
          autoplay: true,
          loop: true,
          onUpdate: function (anim) {
            currentTime = anim.currentTime;
            // Skip one echo right after an external seek
            if (ignoreNextTimeUpdate) {
              ignoreNextTimeUpdate = false;
              return;
            }

            // Only emit while playing
            if (isPlaying) {
              sendMessage('time-update', { currentTime });
            }
          },
          onLoop: function (){
            currentTimeline.restart();
          },
          onComplete: function () {
            sendMessage('animation-complete');
          },
        });

        // Add animations to timeline
        animations.forEach(animation => {
          currentTimeline.add(
            animation.targets,
            processAnimationParams(animation.params),
            animation.position || 0
          );
        });

        // Get total duration and send to parent
        if (currentTimeline.duration) {
          sendMessage('duration-update', {
            duration: currentTimeline.duration,
          });
        }
      }

      // Playback controls
      function play() {
        if (currentTimeline) {
          currentTimeline.play();
          isPlaying = true;
          sendMessage('play-state-changed', { isPlaying: true });
        }
      }

      function pause() {
        if (currentTimeline) {
          currentTimeline.pause();
          isPlaying = false;
          sendMessage('play-state-changed', { isPlaying: false });
        }
      }

      function seek(time) {
        if (currentTimeline) {
          // external seek -> suppress next onUpdate echo
          ignoreNextTimeUpdate = true;
          currentTimeline.seek(time);
          currentTime = time;
          // do not send time-update here; parent already knows
        }
      }

      function restart() {
        if (currentTimeline) {
          currentTimeline.restart();
          currentTime = 0;
          sendMessage('time-update', { currentTime: 0 });
        }
      }

      // Message handler
      window.addEventListener('message', function (event) {
        const { type, data } = event.data;

        switch (type) {
          case 'set-svg-content':
            setSvgContent(data.content);
            break;

          case 'set-animations':
            createAnimationTimeline(data.animations);
            break;

          case 'play':
            play();
            break;

          case 'pause':
            pause();
            break;

          case 'seek':
            seek(data.time);
            break;

          case 'restart':
            restart();
            break;

          case 'get-state':
            sendMessage('state-response', {
              isPlaying,
              currentTime,
              duration: currentTimeline ? currentTimeline.duration : 0,
            });
            break;
        }
      });

      // Initialize
      sendMessage('iframe-ready');
    </script>
  </body>
</html>
